#!/bin/bash
{ # https://stackoverflow.com/a/21100710
set -e

## bkrun is a multi-user task-runner.
##
## The script is currently only tested for Debian-style environments,
## although other POSIX environments may have suitable functionality.

###########################################################################
## General Organization
##
## Users:
## - User "dispatcher" can submit jobs.
## - Users "runner-1", "runner-2", etc can run jobs.
## - Group "runners" includes the dispatcher and all runners.
##
## Paths:
## - /srv/runner/meta			Extra config data
## - /srv/runner/spool			Pending requests
## - /srv/runner/home/dispatcher	Home directory of the dispatcher
## - /srv/runner/home/runner-NNN	Home directory of the Nth runner. This is an overlay, combining "base"+"temp".
## - /srv/runner/base/runner-NNN	Base-layer. Reused across multiple executions.
## - /srv/runner/temp/runner-NNN	Temp-layer. Only used for the duration of one execution.

###########################################################################
## Usage
##
## -- Install (as root)
## $ sudo cp ./path/to/bkrun /usr/local/bin/bkrun
## $ sudo bkrun install
##
## -- Submit a job (as "dispatcher")
## $ sudo bkrun submit -n 99 -c /my/task.sh -o /tmp/output
##
## -- Submit a job via run-bknix job (as "dispatcher")
## $ JOB_NAME=Hello run-bknix-job --mock min
##
## The script "task.sh" will be executed by user "runner-99". It is called in a phases:
##
## $ task.sh request             ## Output any request-data that should be passed to the runner
## $ task.sh setup <REQUEST>     ## Perform pre-init. Output should be safe for re-use. Use this to warm-up caches.
## $ task.sh exec <REQUEST>      ## Execute the task.
## $ task.sh artifacts <REQUEST> ## Output a list of artifacts to be preserved

###########################################################################
## Global Environment
##
## number: The active worker number (1, 2, 3, ...)
## reqfile: The file containing env-vars for this task
## outdir: The folder where artifacts should be deposited
## ctlscript: The script to run as the user
## forward_agent: Whether to forward SSH agent to runner-N (either empty or "-A")
## use_shell: Whether to run interactive shell (either empty or "-s")
##
## runner_user: Name of the user (ex: "runner-1")
## runner_home: Effective home (ex: /srv/runner/home-1)
## runner_base: Persistent layer for task-running (ex: /srv/runner/base-1)
## runner_temp: Temp layer for task-running (ex: /srv/runner/temp-1)

DISPATCH_USER="dispatcher"
DISPATCH_HOME="/srv/runner/home/dispatcher"
RUNNER_TEMP_SIZE=2500m
RUNNER_HOME_TPL=/srv/runner/home/runner-NUM
RUNNER_TEMP_TPL=/srv/runner/temp/runner-NUM
RUNNER_BASE_TPL=/srv/runner/base/runner-NUM
RUNNER_LIMIT=2
RUNNER_META=/srv/runner/meta
RUNNER_SPOOL=/srv/runner/spool
RUNNER_GROUP='runners'
GUARD=

###########################################################################
## Task: Show usage
function usage {
  local prog=$(basename "$0")
  echo "Usage: $prog ACTION [OPTIONS...]"
  echo
  echo "System configuration actions:"
  echo
  echo "       $prog install"
  echo "       $prog uninstall"
  echo
  echo "Public actions:"
  echo
  echo "       $prog submit [-A] [-n NUMBER] [-c CTLSCRIPT|-s] [-o OUTDIR]"
  echo
  echo "Private actions:"
  echo
  echo "       $prog exec [-A] [-n NUMBER] [-c CTLSCRIPT] [-r REQFILE] [-o OUTDIR]"
  echo "       $prog setup [-A] [-n NUMBER] [-c CTLSCRIPT] [-r REQFILE]"
  echo "       $prog mount-base [-n NUMBER]"
  echo "       $prog mount-temp [-n NUMBER]"
  echo "       $prog kill [-n NUMBER]"
  echo "       $prog unmount [-n NUMBER]"
  echo "       $prog clean [-n NUMBER]"
  echo
  echo "Tip: If you would like to interactively run steps, use the \"shell\" (-s) flag:"
  echo
  echo "	$prog submit -n1 -s -o tmpdir"
  echo
  echo "This will open a shell at each for the setup and execution."
  exit 1
}

###########################################################################
## Task: Install POSIX users, groups, data folders
function task_install {
  print_h1 "Install"
  assert_root_user
  assert_cmd seq sudo adduser addgroup getent readlink pgrep killall mktemp tar ssh sshd

  mkdir -p "/srv/runner/home" "/srv/runner/base" "/srv/runner/temp"
  chmod 700 /srv/runner/base /srv/runner/temp ## Not visible to regular users

  if [ ! -d "$RUNNER_META" ]; then mkdir -p "$RUNNER_META" ; fi
  if [ ! -f "$RUNNER_META/id_dispatch" -o ! -f "$RUNNER_META/id_dispatch.pub" ]; then
    ssh-keygen -t ed25519 -f "$RUNNER_META/id_dispatch" -q -N "" -C "dispatch"
  fi

  if ! getent group "$RUNNER_GROUP" >/dev/null ; then
    print_h2 "Add group \"$RUNNER_GROUP\""
    $GUARD addgroup "$RUNNER_GROUP"
  fi

  if ! getent passwd "$DISPATCH_USER" >/dev/null ; then
    print_h2 "Add user \"$DISPATCH_USER\""
    $GUARD adduser "$DISPATCH_USER" --gecos "Bkrun Dispatcher" --home "$DISPATCH_HOME" --ingroup "$RUNNER_GROUP" --disabled-password
  fi
  _install_ssh "$DISPATCH_USER" "$DISPATCH_HOME/.ssh" "$( [ -e /etc/bknix-ci/dispatcher-keys ] && cat /etc/bknix-ci/dispatcher-keys )"

  print_h2 "Update /etc/sudoers.d/bkrun"
  echo -n > /etc/sudoers.d/bkrun
  echo "Defaults:dispatcher env_keep+=SSH_AUTH_SOCK" >> /etc/sudoers.d/bkrun
  ## Jenkins may confer ssh rights for specific tasks, and those should pass-through.
  echo "${DISPATCH_USER} ALL = (root) NOPASSWD: NOSETENV: /usr/local/bin/bkrun" >> /etc/sudoers.d/bkrun

  for n in `seq 0 $RUNNER_LIMIT` ; do
    number=$n
    compute_defaults
    if ! getent passwd "$runner_user" >/dev/null ; then
      print_h2 "Add user \"$runner_user\""
      $GUARD adduser "$runner_user" --gecos "Bkrun Runner $number" --home "$runner_home" --ingroup "$RUNNER_GROUP" --disabled-password
      $GUARD mv "$runner_home" "$runner_base"
      $GUARD mkdir "$runner_home"
      $GUARD chown "$runner_user:$RUNNER_GROUP" "$runner_home"
    fi
    _install_ssh "$runner_user" "$runner_base/.ssh" "$(cat $RUNNER_META/id_dispatch.pub)"
  done

  if [ ! -d "$RUNNER_SPOOL" ]; then mkdir -p "$RUNNER_SPOOL" ; fi
  chown "$DISPATCH_USER:$RUNNER_GROUP" "$RUNNER_SPOOL"
  chmod 750 "$RUNNER_SPOOL"

  exit ## We just polluted the environment with compute_defaults!
}

## Apply some generic steps to the base setup
## _install_ssh <user> <ssh_dir> <authorized_keys>
function _install_ssh() {
  local tgt_user="$1"
  local ssh_dir="$2"
  local authorized_keys="$3"

  print_h2 "Setup SSH for \"$tgt_user\""

  if [ ! -d "$ssh_dir" ]; then
    mkdir -p "$ssh_dir"
  fi
  chown "root:$RUNNER_GROUP" "$ssh_dir"
  chmod 750 "$ssh_dir"

  echo "$authorized_keys" > "$ssh_dir/authorized_keys"
  chown "root:$RUNNER_GROUP" "$ssh_dir/authorized_keys"
  chmod 640 "$ssh_dir/authorized_keys"

  ssh-keyscan localhost > "$ssh_dir/known_hosts"
  chown "$tgt_user:$RUNNER_GROUP" "$ssh_dir/known_hosts"
  chmod 640 "$ssh_dir/known_hosts"
}

###########################################################################
## Task: Uninstall POSIX users, groups, data folders
function task_uninstall {
  print_h1 "Uninstall"
  assert_root_user
  assert_cmd seq sudo deluser delgroup getent

  if [ -f /etc/sudoers.d/bkrun ]; then
    $GUARD rm -f /etc/sudoers.d/bkrun
  fi

  $GUARD rm -rf /srv/runner

  if getent passwd "$DISPATCH_USER" >/dev/null ; then
    $GUARD deluser "$DISPATCH_USER"
  fi

  for n in `seq 0 $RUNNER_LIMIT` ; do
    number=$n
    compute_defaults
    if getent passwd "$runner_user" >/dev/null ; then
      $GUARD deluser "$runner_user"
    fi
  done

  if getent group "$RUNNER_GROUP" >/dev/null ; then
    $GUARD delgroup "$RUNNER_GROUP"
  fi
  exit
}

###########################################################################
## Task: Take the current environment. Submit it to a runner.
function task_submit {
  assert_number
  assert_ctlscript
  assert_not_root_user
  assert_outdir 1

  trap "_task_submit_exit" EXIT

  reqfile="$RUNNER_SPOOL"/$(date '+%Y-%m-%d-%H-%M'-$RANDOM$RANDOM)
  dispatch_me request > "$reqfile"
  chgrp "$RUNNER_GROUP" "$reqfile"
  chmod 640 "$reqfile"

  local real_outdir=$( readlink -f "$outdir" )

  sudo bkrun exec -n "$number" -c "$ctlscript" -r "$reqfile" -o "$real_outdir" $forward_agent
}

function _task_submit_exit {
  if [ -f "$reqfile" ]; then
    rm "$reqfile"
  fi
  if [ -n "$use_shell" ]; then rm -f "$ctlscript" ; fi
}

###########################################################################
## Task: Execute a task. This includes setup, execution, and teardown.
function task_exec {
  assert_root_user
  assert_ctlscript
  assert_reqfile
  assert_outdir

  task_clean
  trap "_task_exec_exit" EXIT
  task_setup
  task_mount_temp

  print_h1 "Execute task"
  dispatch_runner exec "$reqfile"
}

function _task_exec_exit {
  task_artifacts
  task_clean
}

###########################################################################
## Task: Sync outbound artifacts
function task_artifacts {
  print_h1 "Return artifacts"
  assert_root_user
  assert_reqfile
  assert_outdir

  local extract_cmd=$(printf "cd %q && tar x" "$outdir"  )
  dispatch_runner artifacts "$reqfile" | tee /tmp/transfer.tar | su - dispatcher -c "$extract_cmd"
}

###########################################################################
## Task: Setup worker environment
function task_setup {
  print_h1 "Setup"
  assert_root_user
  assert_reqfile

  task_mount_base
  pushd "$runner_home" >> /dev/null
    dispatch_runner setup "$reqfile"
  popd >> /dev/null
  task_kill
  task_unmount
}

###########################################################################
## Task: Cleanup
function task_clean {
  print_h1 "Cleanup"
  assert_root_user
  task_kill
  task_unmount
  if [ -n "$runner_user" ]; then
    find -P /tmp /var/tmp /var/crash -user "$runner_user" -delete
  fi
}

###########################################################################
## Task: Kill processes
function task_kill {
  assert_root_user
  local count=0

  while true; do
    if [ -z "$(pgrep -U "$runner_user")" ]; then
      return
    fi

    case "$count" in
      0)
        print_h2 "Kill $runner_user"
        $GUARD killall --user "$runner_user"
        ;;
      10)
        print_h2 "Kill $runner_user (-9)"
        $GUARD killall -9 --wait --user "$runner_user"
        ;;
    esac

    print_h2 "Waiting... ($count)"
    $GUARD sleep 1
    count=$((count+1))
  done
}

###########################################################################
## Task: Mount base
function task_mount_base {
  print_h2 "Mount home ($runner_home) with base ($runner_base)"
  assert_root_user

  $GUARD mount --bind "$runner_base" "$runner_home"
}

###########################################################################
## Task: Mount temp
function task_mount_temp {
  print_h2 "Mount home ($runner_home) with temp ($runner_temp)"
  assert_root_user

  $GUARD mkdir -p "$runner_temp"
  $GUARD mount -t tmpfs -o "size=${RUNNER_TEMP_SIZE}" tmpfs "$runner_temp"
  $GUARD mkdir "$runner_temp/up" "$runner_temp/work"
  $GUARD chown "$runner_user:$RUNNER_GROUP" "$runner_temp/up" "$runner_temp/work"
  $GUARD mount -t overlay overlay -o lowerdir="$runner_base",upperdir="$runner_temp/up",workdir="$runner_temp/work" "$runner_home"
  $GUARD chown "$runner_user:$RUNNER_GROUP" "$runner_base"
}

###########################################################################
## Task: Unmount
function task_unmount {
  assert_root_user
  if grep -q "$runner_home" /proc/mounts; then
    print_h2 "Unmount home ($runner_home)"
    $GUARD umount "$runner_home"
  fi
  if grep -q "$runner_temp" /proc/mounts; then
    print_h2 "Unmount temp ($runner_temp)"
    $GUARD umount "$runner_temp"
  fi
}

###########################################################################
## Run a subtask (as current user)
## usage: dispatch_me <hook-name> [...options...]
function dispatch_me {
  assert_ctlscript
  assert_not_root_user
  $GUARD "$ctlscript" "$@"
}

## Run a subtask (as runner-$N)
## usage: dispatch_runner <hook-name> [...options...]
function dispatch_runner {
  assert_ctlscript
  assert_root_user

  ## sudo is faster/simpler, but "ssh -A" can relay job-specific credentials from Jenkins.
  if [ -z "$forward_agent" ]; then
    print_h2 >&2 "Dispatch $2 without SSH"
    $GUARD sudo -iu "runner-$number" "$ctlscript" "$@"
  else
    print_h2 >&2 "Dispatch $2 with SSH"
    $GUARD ssh -A -i "$RUNNER_META/id_dispatch"  "runner-$number@localhost" "$ctlscript" "$@"
  fi
}

###########################################################################
function print_h1 {
  echo [33m"##" "$@" [0m
}

function print_h2 {
  echo [33m"$@"[0m
}

function fatal {
  echo "$@" >&2
  exit 2
}

function create_shell_stub() {
  echo '#!/usr/bin/env bash'
  echo 'case "$1" in'
  echo '  setup) echo >&2 "BEGIN SETUP PHASE. TO CONTINUE, PRESS Ctrl-D." ; bash ; ;; '
  echo '  exec) echo >&2 "BEGIN EXEC PHASE. TO CONTINUE, PRESS Ctrl-D." ; bash ; ;; '
  echo '  artifacts) echo >&2 "SKIP ARTIFACTS PHASE" ; tar c -T /dev/null ; ;;'
  echo 'esac'
}

###########################################################################
## Assertions

function assert_number() {
  if [ -z "$number" ]; then
    fatal "Missing option: -n NUMBER"
  fi
  case "$number" in
    ''|*[!0-9]*) fatal "Number parameter (-n) does not specify a number" ;;
  esac
  if [ "$number" -gt "$RUNNER_LIMIT" ]; then
    fatal "Number $number exceeds limit $RUNNER_LIMIT"
  fi
}

function assert_ctlscript {
  if [ -z "$ctlscript" ]; then
    fatal "Missing option: [-c CTLSCRIPT]"
  fi
  if [ ! -e "$ctlscript" ]; then
    fatal "CTLSCRIPT ($ctlscript) not found"
  fi
}

function assert_reqfile {
  if [ -z "$reqfile" ]; then
    fatal "Missing option: [-r REQFILE]"
  fi
  if [ ! -e "$reqfile" ]; then
    fatal "REQFILE ($reqfile) not found"
  fi
}

## usage: assert_outdir <allow-auto-create>
function assert_outdir {
  if [ -z "$outdir" ]; then
    fatal "Missing option: [-o OUTDIR]"
  fi
  if [ ! -e "$outdir" -a -n "$1" ]; then
    mkdir -p "$outdir"
  fi
  if [ ! -e "$outdir" ]; then
    fatal "OUTDIR ($outdir) not found"
  fi
}

function assert_cmd {
  for cmd in "$@" ; do
    if ! command -v "$cmd" &> /dev/null ; then
      fatal "Missing command: $cmd"
    fi
  done
}

function assert_root_user() {
  if [ "$USER" != "root" ]; then
    echo "This command must run as a super user - not a regular user!" 1>&2
    exit 1
  fi
}

function assert_not_root_user() {
  if [ "$USER" == "root" ]; then
    echo "This command must run as a regular user - not as root!" 1>&2
    exit 1
  fi
}

###########################################################################
## Fill in some computed variables
function compute_defaults {
  assert_number
  runner_user="runner-${number}"
  runner_home=$( echo "${RUNNER_HOME_TPL}" | sed "s;NUM;${number};" )
  runner_base=$( echo "${RUNNER_BASE_TPL}" | sed "s;NUM;${number};" )
  runner_temp=$( echo "${RUNNER_TEMP_TPL}" | sed "s;NUM;${number};" )
}

###########################################################################
## Main

if [ $# -lt 1 ]; then
  usage
fi

cmd=$1
shift

case $cmd in
  install|uninstall|submit|exec|setup|mount-base|mount-temp|unmount|kill|clean)
    ;;
  *)
    usage
    ;;
esac

forward_agent=
while getopts ":n:r:c:o:hsA" opt; do
  case $opt in
    n)
      number=$OPTARG
      ;;
    r)
      reqfile=$OPTARG
      ;;
    c)
      ctlscript=$( readlink -f "$OPTARG" )
      ;;
    s)
      ctlscript=$( mktemp )
      create_shell_stub > "$ctlscript"
      chmod 755 "$ctlscript"
      use_shell="-s"
      ;;
    o)
      outdir=$OPTARG
      ;;
    h)
      usage
      ;;
    A)
      forward_agent="-A"
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      usage >&2
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      usage >&2
      ;;
  esac
done

if [ -z "$forward_agent" ]; then
  unset SSH_AUTH_SOCK
fi

case $cmd in
  install)      task_install     ; ;;
  uninstall)    task_uninstall   ; ;;
  submit)       task_submit      ; ;;
  exec)         compute_defaults ; task_exec    ; ;;
  setup)        compute_defaults ; task_setup   ; ;;
  artifact)     compute_defaults ; task_artifact ; ;;
  mount-base)   compute_defaults ; task_unmount ; task_mount_base ; ;;
  mount-temp)   compute_defaults ; task_unmount ; task_mount_temp ; ;;
  unmount)      compute_defaults ; task_unmount ; ;;
  kill)         compute_defaults ; task_kill    ; ;;
  clean)        compute_defaults ; task_clean   ; ;;
esac

exit
} # https://stackoverflow.com/a/21100710
