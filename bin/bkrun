#!/bin/bash
set -e

## bkrun is a multi-user task-runner.
##
## The script is currently only tested for Debian-style environments,
## although other POSIX environments may have suitable functionality.

###########################################################################
## General Organization
##
## Users:
## - User "dispatcher" can submit jobs.
## - Users "runner-1", "runner-2", etc can run jobs.
## - Group "runners" includes the dispatcher and all runners.
##
## Paths:
## - /srv/runner/dispatcher/home	Home directory of the dispatcher
## - /srv/runner/NNN/home		Home directory of the Nth runner. This is an overlay, combining "base"+"temp".
## - /srv/runner/NNN/base		Base-layer. Reused across multiple executions.
## - /srv/runner/NNN/temp		Temp-layer. Only used for the duration of one execution.

###########################################################################
## Usage
##
## -- Install (as root)
## $ sudo cp ./path/to/bkrun /usr/local/bin/bkrun
## $ sudo bkrun install
##
## -- Submit a job (as "dispatcher")
## $ sudo bkrun submit -n 99 -c /my/task.sh -o /tmp/output
##
## The script "task.sh" will be executed by user "runner-99". It is called in a phases:
##
## $ task.sh request             ## Output any request-data that should be passed to the runner
## $ task.sh setup <REQUEST>     ## Perform pre-init. Output should be safe for re-use. Use this to warm-up caches.
## $ task.sh exec <REQUEST>      ## Execute the task.
## $ task.sh artifacts <REQUEST> ## Output a list of artifacts to be preserved

###########################################################################
## Global Environment
##
## number: The active worker number (1, 2, 3, ...)
## reqfile: The file containing env-vars for this task
## outdir: The folder where artifacts should be deposited
## ctlscript: The script to run as the user
## runner_user: Name of the user (ex: "runner-1")
## runner_home: Effective home (ex: /srv/runner/home-1)
## runner_base: Persistent layer for task-running (ex: /srv/runner/base-1)
## runner_temp: Temp layer for task-running (ex: /srv/runner/temp-1)

DISPATCH_USER="dispatcher"
DISPATCH_HOME="/srv/runner/dispatcher/home"
RUNNER_TEMP_SIZE=2500m
RUNNER_HOME_TPL=/srv/runner/NUM/home
RUNNER_TEMP_TPL=/srv/runner/NUM/temp
RUNNER_BASE_TPL=/srv/runner/NUM/base
RUNNER_LIMIT=2
RUNNER_GROUP='runners'
GUARD=

###########################################################################
## Task: Show usage
function usage {
  local prog=$(basename "$0")
  echo "Usage: $prog ACTION [OPTIONS...]"
  echo
  echo "System configuration actions:"
  echo
  echo "       $prog install"
  echo "       $prog uninstall"
  echo
  echo "Public actions:"
  echo
  echo "       $prog submit [-n NUMBER] [-c CTLSCRIPT] [-o OUTDIR]"
  echo
  echo "Private actions:"
  echo
  echo "       $prog exec [-n NUMBER] [-c CTLSCRIPT] [-r REQFILE] [-o OUTDIR]"
  echo "       $prog setup [-n NUMBER] [-c CTLSCRIPT] [-r REQFILE]"
  echo "       $prog mount-base [-n NUMBER]"
  echo "       $prog mount-temp [-n NUMBER]"
  echo "       $prog kill [-n NUMBER]"
  echo "       $prog unmount [-n NUMBER]"
  echo "       $prog clean [-n NUMBER]"
  exit 1
}

###########################################################################
## Task: Install POSIX users, groups, data folders
function task_install {
  print_h1 "Install"
  assert_cmd seq sudo adduser addgroup getent readlink pgrep killall mktemp

  if ! getent group "$RUNNER_GROUP" >/dev/null ; then
    print_h2 "Add group \"$RUNNER_GROUP\""
    $GUARD addgroup "$RUNNER_GROUP"
  fi

  if ! getent passwd "$DISPATCH_USER" >/dev/null ; then
    print_h2 "Add user \"$DISPATCH_USER\""
    $GUARD adduser "$DISPATCH_USER" --gecos "Bkrun Dispatcher" --home "$DISPATCH_HOME" --ingroup "$RUNNER_GROUP" --disabled-password
  fi

  print_h2 "Update /etc/sudoers.d/bkrun"
  echo "${DISPATCH_USER} ALL = (root) NOPASSWD: NOSETENV: /usr/local/bin/bkrun" > /etc/sudoers.d/bkrun

  for n in `seq 1 $RUNNER_LIMIT` ; do
    number=$n
    compute_defaults
    if ! getent passwd "$runner_user" >/dev/null ; then
      print_h2 "Add user \"$runner_user\""
      $GUARD mkdir -p $(dirname "$runner_home") $(dirname "$runner_base") $(dirname "$runner_temp")
      $GUARD adduser "$runner_user" --gecos "Bkrun Runner $number" --home "$runner_home" --ingroup "$RUNNER_GROUP" --disabled-password
      $GUARD mv "$runner_home" "$runner_base"
      $GUARD mkdir "$runner_home"
      $GUARD chown "$runner_user:$RUNNER_GROUP" "$runner_home"
    fi
  done


  exit ## We just polluted the environment with compute_defaults!
}

###########################################################################
## Task: Uninstall POSIX users, groups, data folders
function task_uninstall {
  print_h1 "Uninstall"
  assert_cmd seq sudo deluser delgroup getent

  if [ -f /etc/sudoers.d/bkrun ]; then
    $GUARD rm -f /etc/sudoers.d/bkrun
  fi

  $GUARD rm -rf /srv/runner

  if getent passwd "$DISPATCH_USER" >/dev/null ; then
    $GUARD deluser "$DISPATCH_USER"
  fi

  for n in `seq 1 $RUNNER_LIMIT` ; do
    number=$n
    compute_defaults
    if getent passwd "$runner_user" >/dev/null ; then
      $GUARD deluser "$runner_user"
    fi
  done

  if getent group "$RUNNER_GROUP" >/dev/null ; then
    $GUARD delgroup "$RUNNER_GROUP"
  fi
  exit
}

###########################################################################
## Task: Take the current environment. Submit it to a runner.
function task_submit {
  assert_number
  assert_ctlscript
  assert_not_root_user
  assert_outdir 1

  trap "_task_submit_exit" EXIT

  reqfile=$(mktemp)
  dispatch_me request > "$reqfile"
  chgrp "$RUNNER_GROUP" "$reqfile"
  chmod 640 "$reqfile"

  sudo bkrun exec -n "$number" -c "$ctlscript" -r "$reqfile" -o "$outdir"
}

function _task_submit_exit {
  if [ -f "$reqfile" ]; then
    rm "$reqfile"
  fi
}

###########################################################################
## Task: Execute a task. This includes setup, execution, and teardown.
function task_exec {
  assert_root_user
  assert_ctlscript
  assert_reqfile
  assert_outdir

  task_clean
  trap "_task_exec_exit" EXIT
  task_setup
  task_mount_temp

  print_h1 "Execute task"
  dispatch_runner exec "$reqfile"
}

function _task_exec_exit {
  task_artifacts
  task_clean
}

###########################################################################
## Task: Sync outbound artifacts
function task_artifacts {
  assert_root_user
  assert_reqfile
  print_h1 "Return artifacts"

  dispatch_runner artifacts "$reqfile" | grep -v '^#' | while read LINE ; do
    echo "Inspect LINE [$LINE] and sync it"
  done
}

###########################################################################
## Task: Setup worker environment
function task_setup {
  assert_root_user
  print_h1 "Setup"

  task_mount_base
  assert_reqfile
  dispatch_runner setup "$reqfile"
  task_unmount
}

###########################################################################
## Task: Cleanup
function task_clean {
  assert_root_user
  print_h1 "Cleanup"
  task_kill
  task_unmount
}

###########################################################################
## Task: Kill processes
function task_kill {
  assert_root_user
  if [ -n "$(pgrep -U "$runner_user")" ]; then
    print_h2 "Kill $runner_user"
    $GUARD killall --user "$runner_user"
    $GUARD sleep 4
    if [ -n "$(pgrep -U "$runner_user")" ]; then
    print_h2 "Kill $runner_user (-9)"
      $GUARD killall -9 --wait --user "$runner_user"
    fi
  fi
}

###########################################################################
## Task: Mount base
function task_mount_base {
  assert_root_user
  print_h2 "Mount home ($runner_home) with base ($runner_base)"
  $GUARD mount --bind "$runner_base" "$runner_home"
}

###########################################################################
## Task: Mount temp
function task_mount_temp {
  assert_root_user
  print_h2 "Mount home ($runner_home) with temp ($runner_temp)"
  $GUARD mkdir -p "$runner_temp"
  $GUARD mount -t tmpfs -o "size=${RUNNER_TEMP_SIZE}" tmpfs "$runner_temp"
  $GUARD mkdir "$runner_temp/up" "$runner_temp/work"
  $GUARD chown "$runner_user:$RUNNER_GROUP" "$runner_temp/up" "$runner_temp/work"
  $GUARD mount -t overlay overlay -o lowerdir="$runner_base",upperdir="$runner_temp/up",workdir="$runner_temp/work" "$runner_home"
  $GUARD chown "$runner_user:$RUNNER_GROUP" "$runner_base"
}

###########################################################################
## Task: Unmount
function task_unmount {
  assert_root_user
  if grep -q "$runner_home" /proc/mounts; then
    print_h2 "Unmount home ($runner_home)"
    $GUARD umount "$runner_home"
  fi
  if grep -q "$runner_temp" /proc/mounts; then
    print_h2 "Unmount temp ($runner_temp)"
    $GUARD umount "$runner_temp"
  fi
}

###########################################################################
## Run a subtask (as current user)
## usage: dispatch_me <hook-name> [...options...]
function dispatch_me {
  assert_ctlscript
  assert_not_root_user
  $GUARD "$ctlscript" "$@"
}

## Run a subtask (as runner-$N)
## usage: dispatch <hook-name> [...options...]
function dispatch_runner {
  assert_ctlscript
  assert_root_user
  $GUARD sudo -iu "runner-$number" "$ctlscript" "$@"
}

###########################################################################
function print_h1 {
  echo [33m"##" "$@" [0m
}

function print_h2 {
  echo [33m"$@"[0m
}

function fatal {
  echo "$@" >&2
  exit 2
}

###########################################################################
## Assertions

function assert_number() {
  if [ -z "$number" ]; then
    fatal "Missing option: -n NUMBER"
  fi
  if [ "$number" -gt "$RUNNER_LIMIT" ]; then
    fatal "Number $number exceeds limit $RUNNER_LIMIT"
  fi
}

function assert_ctlscript {
  if [ -z "$ctlscript" ]; then
    fatal "Missing option: [-c CTLSCRIPT]"
  fi
  if [ ! -e "$ctlscript" ]; then
    fatal "CTLSCRIPT ($ctlscript) not found"
  fi
}

function assert_reqfile {
  if [ -z "$reqfile" ]; then
    fatal "Missing option: [-r REQFILE]"
  fi
  if [ ! -e "$reqfile" ]; then
    fatal "REQFILE ($reqfile) not found"
  fi
}

## usage: assert_outdir <allow-auto-create>
function assert_outdir {
  if [ -z "$outdir" ]; then
    fatal "Missing option: [-o OUTDIR]"
  fi
  if [ ! -e "$outdir" -a -n "$1" ]; then
    mkdir -p "$outdir"
  fi
  if [ ! -e "$outdir" ]; then
    fatal "OUTDIR ($outdir) not found"
  fi
}

function assert_cmd {
  for cmd in "$@" ; do
    if ! command -v "$cmd" &> /dev/null ; then
      fatal "Missing command: $cmd"
    fi
  done
}

function assert_root_user() {
  if [ "$USER" != "root" ]; then
    echo "This command must run as a super user - not a regular user!" 1>&2
    exit 1
  fi
}

function assert_not_root_user() {
  if [ "$USER" == "root" ]; then
    echo "This command must run as a regular user - not as root!" 1>&2
    exit 1
  fi
}

###########################################################################
## Fill in some computed variables
function compute_defaults {
  assert_number
  runner_user="runner-${number}"
  runner_home=$( echo "${RUNNER_HOME_TPL}" | sed "s;NUM;${number};" )
  runner_base=$( echo "${RUNNER_BASE_TPL}" | sed "s;NUM;${number};" )
  runner_temp=$( echo "${RUNNER_TEMP_TPL}" | sed "s;NUM;${number};" )
}

###########################################################################
## Main

if [ $# -lt 1 ]; then
  usage
fi

cmd=$1
shift

case $cmd in
  install|uninstall|submit|exec|setup|mount-base|mount-temp|unmount|kill|clean)
    ;;
  *)
    usage
    ;;
esac

while getopts ":n:r:c:o:h" opt; do
  case $opt in
    n)
      number=$OPTARG
      ;;
    r)
      reqfile=$OPTARG
      ;;
    c)
      ctlscript=$OPTARG
      ;;
    o)
      outdir=$OPTARG
      ;;
    h)
      usage
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      usage >&2
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      usage >&2
      ;;
  esac
done

case $cmd in
  install)      task_install     ; ;;
  uninstall)    task_uninstall   ; ;;
  submit)       task_submit      ; ;;
  exec)         compute_defaults ; task_exec    ; ;;
  setup)        compute_defaults ; task_setup   ; ;;
  mount-base)   compute_defaults ; task_unmount ; task_mount_base ; ;;
  mount-temp)   compute_defaults ; task_unmount ; task_mount_temp ; ;;
  unmount)      compute_defaults ; task_unmount ; ;;
  kill)         compute_defaults ; task_kill    ; ;;
  clean)        compute_defaults ; task_clean   ; ;;
esac
