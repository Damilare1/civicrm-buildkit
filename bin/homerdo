#!/usr/bin/env bash
{ # https://stackoverflow.com/a/21100710
  set -e

  #########################################################
  ## Environment
  SELF="$(realpath "$0")"
  HOMER_VAR=/var/local/homer
  HOMER_USER=homer
  HOMER_GROUP=homer
  HOMER_BASE_TPL="$HOMER_VAR/HOMER_ID/base"
  HOMER_HOME_TPL="$HOMER_VAR/HOMER_ID/home"
  HOMER_LOCK_TPL="$HOMER_VAR/HOMER_ID/lock"
  HOMER_NS_TPL="$HOMER_VAR/HOMER_ID/ns"
  HOMER_TEMP_TPL="$HOMER_VAR/HOMER_ID/temp"
  GUARD=

  img=
  action=
  use_temp=
  owner_pid=$$
  envfiles=()
  shares=()
  cmd=()
  size=2500m
  verbose=0

  cleanup_files=()
  cleanup_mounts=

  homer_id=		## see realize_img
  homer_base=		## see realize_img
  homer_home=		## see realize_img
  homer_lock=		## see realize_img
  homer_ns=		## see realize_img
  homer_temp=		## see realize_img

  #########################################################
  ## Usage

  function task_usage() {
    prog=$(basename "$0")
    echo "Public actions:"
    echo "  $prog install"
    echo "  $prog run [OPTIONS] [--] [CMD]"
    echo "  $prog status [OPTIONS]"
    echo "  $prog uninstall"
    echo
    echo "Private actions:"
    echo "  $prog create [OPTIONS]"
    echo "  $prog mount [OPTIONS]"
    echo "  $prog unmount [OPTIONS]"
    echo "  $prog exec [OPTIONS] [--] [CMD]"
    echo
    echo "Options:"
    echo "  -i|--img IMG         Path to image file"
    #echo "  --env ENV_FILE       File with environment variables"
    #echo "  --share REL_PATH     Mount a shared folder"
    echo "  -t|--temp            Use temporary overlay."
    echo
  }

  ###########################################################################
  ## Task: Install POSIX users, groups, data folders

  function task_install {
    print_h1 "Install"
    assert_root_user
    assert_cmd sudo adduser addgroup getent realpath ps pgrep killall unshare flock setfacl

    mkdir -p "$HOMER_VAR"
    chmod 700 "$HOMER_VAR"

    if ! getent group "$HOMER_GROUP" >/dev/null ; then
      print_h2 "Add group \"$HOMER_GROUP\""
      $GUARD addgroup "$HOMER_GROUP"
    fi

    if ! getent passwd "$HOMER_USER" >/dev/null ; then
      print_h2 "Add user \"$HOMER_USER\""
      $GUARD adduser "$HOMER_USER" --gecos "Homer" --home "/home/homer" --ingroup "$HOMER_GROUP" --disabled-password
    fi

    print_h2 "Grant all users access to homerdo (/etc/sudoers.d/homerdo)"
    echo -n > /etc/sudoers.d/homerdo
    echo "ALL ALL = (root) NOPASSWD: NOSETENV: /usr/local/bin/homerdo" >> /etc/sudoers.d/homerdo
  }

  ###########################################################################
  ## Task: Uninstall POSIX users, groups, data folders
  function task_uninstall {
    print_h1 "Uninstall"
    assert_root_user
    assert_cmd seq sudo deluser delgroup getent

    if [ -f /etc/sudoers.d/homerdo ]; then
      $GUARD rm -f /etc/sudoers.d/homerdo
    fi

    $GUARD rm -rf "$HOMER_VAR"

    if getent passwd "$HOMER_USER" >/dev/null ; then
      $GUARD deluser "$HOMER_USER"
    fi

    if getent group "$HOMER_GROUP" >/dev/null ; then
      $GUARD delgroup "$HOMER_GROUP"
    fi
    exit
  }

  ###########################################################################
  ## Task: Setup folders, run a command, and tear down

  function task_run() {
    print_h1 "Run [${cmd[@]}]"
    assert_not_root_user

    if [ -z "$img" ]; then
      fatal "No IMG specified"
    fi

    assert_valid_envfiles; realize_envfiles
    assert_valid_shares; realize_shares

    if [ ! -e "$img" ]; then
      task_create
    fi
    assert_valid_img; realize_img

    cleanup_mounts=1
    as_root mount
    as_root exec -- "${cmd[@]}"
  }

  ###########################################################################
  ## Create an image for storing data

  function task_create() {
    print_h2 "Create image ($img, $size)"
    assert_not_root_user

    qemu-img create "$img" "$size"
    mkfs -t ext4 "$img"
  }

  ###########################################################################
  ## Setup folders. Mount image.

  function task_mount() {
    print_h2 "Mounting image file ($img)"
    assert_root_user

    assert_valid_envfiles; realize_envfiles
    assert_valid_shares; realize_shares
    assert_valid_img; realize_img

    assert_ownership

    $GUARD mkdir -p "$homer_base" "$homer_temp" "$homer_home" $(dirname "$homer_lock")

    if [ -f "$homer_lock" ]; then
      local lock_pid=$(cat "$homer_lock")
      if ps -p "$lock_pid" > /dev/null; then
        echo "Image $img already in use by PID $lock_pid"
        exit 2
      else
        rm -f "$homer_lock"
        _task_unmount
      fi
    fi
    echo "$owner_pid" > "$homer_lock"

    print_h2 "Mount ($homer_base)"
    $GUARD mount -o loop "$img" "$homer_base"
    $GUARD chown "$HOMER_USER:$HOMER_GROUP" "$homer_base"
    if [ -n "$use_temp" ]; then
      print_h2 "Mount ($homer_temp)"
      $GUARD mount -t tmpfs -o "size=${size}" tmpfs "$homer_temp"
      $GUARD mkdir "$homer_temp/up" "$homer_temp/work"
      $GUARD chown "$HOMER_USER:$HOMER_GROUP" "$homer_temp/up" "$homer_temp/work"

      print_h2 "Mount ($homer_home)"
      $GUARD mount -t overlay overlay -o lowerdir="$homer_base",upperdir="$homer_temp/up",workdir="$homer_temp/work" "$homer_home"
      $GUARD chown "$HOMER_USER:$HOMER_GROUP" "$homer_home"
    else
      print_h2 "Mount ($homer_home)"
      $GUARD mount --bind "$homer_base" "$homer_home"
    fi
  }

  ###########################################################################
  ## Unmount image and its related assets

  function task_unmount() {
    print_h2 "Unmounting image file ($img)"
    assert_root_user

    assert_valid_envfiles; realize_envfiles
    assert_valid_shares; realize_shares
    assert_valid_img; realize_img

    assert_ownership
    _task_unmount
  }

  function _task_unmount() {
    for nsmt in "$homer_ns/pid" "$homer_ns/mount"; do
      if [ -e "$nsmt" ]; then
        print_h2 "Unmount ($nsmt)"
        $GUARD umount "$nsmt"
        $GUARD rm "$nsmt"
      fi
    done

    for mpt in "$homer_ns" "$homer_home" "$homer_temp" "$homer_base" ; do
      if grep -q "$mpt" /proc/mounts; then
        print_h2 "Unmount ($mpt)"
        $GUARD umount "$mpt"
      fi
    done
  }

  ###########################################################################
  ## Execute a task within the designated space

  function task_exec() {
    print_h2 "Exec (${cmd[@]})"
    assert_root_user

    assert_valid_envfiles; realize_envfiles
    assert_valid_shares; realize_shares
    assert_valid_img; realize_img

    assert_ownership

    local script=$(new_tmp_file)
    cleanup_files+=("$script")
    _task_exec_script > "$script"

    print_h2 "Create namespaces ($homer_ns)"
    mkdir -p "$homer_ns"
    mount --bind "$homer_ns" "$homer_ns"
    mount --make-private "$homer_ns"
    touch "$homer_ns"/{pid,mount}
    unshare --wd=/tmp --kill-child --pid="$homer_ns/pid" --mount="$homer_ns/mount" --mount-proc bash "$script"
  }

  function _task_exec_script() {
    printf "#!/usr/bin/env bash\n"
    printf "function cleanup() {\n"
    printf "  umount %q\n" ~homer
    printf "}\n"
    printf "mount --bind %q %q\n" "$homer_home" ~homer
    printf "trap cleanup EXIT\n"
    echo "sudo -iu "$HOMER_USER" ${cmd[@]}"
  }

  ###########################################################################
  ## Check if image is in use

  function task_status() {
    assert_valid_envfiles; realize_envfiles
    assert_valid_shares; realize_shares
    assert_valid_img; realize_img

    if [ $EUID -ne 0 ]; then
      as_root status
      exit $?
    fi
    assert_root_user
    assert_ownership

    local lock_pid=$(cat "$homer_lock")
    if ps -p "$lock_pid" > /dev/null; then
      echo "active"
      exit 11
    else
      echo "avail"
      exit 10
    fi
    echo "avail"
    exit 10
  }

  ###########################################################################
  ## Cleanup any temporary resources owned by this instance

  function task_cleanup() {
    set +e
    #print_h2 "Cleanup"
    if [ -n "$cleanup_mounts" ]; then
      as_root unmount
    fi
    for file in "${cleanup_files[@]}" ; do
      if [ -f "$file" ]; then rm -f "$file" ; fi
    done
  }

  #########################################################
  ## Functions / Utilities

  function print_h1 {
    if [ $verbose -ge 1 ]; then
      echo [32m"##" "$@" [0m >&2
    fi
  }

  function print_h2 {
    if [ $verbose -ge 1 ]; then
      echo [33m"$@"[0m >&2
    fi
  }

  function print_note {
    if [ $verbose -ge 2 ]; then
      echo "[[ $@ ]]" >&2
    fi
  }

  function fatal {
    echo "$@" >&2
    task_usage >&2
    exit 1
  }

  function new_tmp_file() {
    local tmpdir=${TMPDIR:-/tmp}
    local tmpfile="$tmpdir/homerdo-tmp-$RANDOM$RANDOM"
    touch "$tmpfile"
    chmod 600 "$tmpfile"
    echo "$tmpfile"
  }

  function as_root() {
    #local tmpfile=$(new_tmp_file)
    #cleanup_files+=("$tmpfile")
    #declare -x > "$tmpfile"

    local sudocmd=("$SELF")
    if [ -n "$use_temp" ]; then
      sudocmd+=("$use_temp")
    fi
    #sudocmd+=("--env" "$tmpfile")
    sudocmd+=("-i" "$img")
    sudocmd+=("--owner-pid" "$owner_pid")
    local vs=0
    while [[ $vs -lt $verbose ]]; do
      sudocmd+=("-v")
      vs=$((1 + $vs))
    done
    for envfile in "${envfiles[@]}" ; do sudocmd+=("--env" "$envfile") ; done
    for share in "${shares[@]}" ; do sudocmd+=("--share" "$share") ; done
    for arg in "$@" ; do sudocmd+=("$arg") ; done

    local result
    set +e
    print_note "sudo -i ${sudocmd[@]}"
    sudo -i "${sudocmd[@]}"
    result=$?
    set -e
    return $result
  }

  function assert_cmd {
    for cmd in "$@" ; do
      if ! command -v "$cmd" &> /dev/null ; then
        fatal "Missing command: $cmd"
      fi
    done
  }

  function assert_root_user() {
    if [ $EUID -ne 0 ]; then
      fatal "This command ($SELF $action) must run as a super user - not a regular user!"
    fi
  }

  function assert_not_root_user() {
    if [ $EUID -eq 0 ]; then
      fatal "This command ($SELF $action) must run as a regular user - not as root!"
    fi
  }

  function assert_valid_img() {
    if [ -z "$img" -o ! -f "$img" ]; then
      fatal "Invalid IMG ($img)"
    fi
  }

  function assert_valid_envfiles() {
    for envfile in "${envfiles[@]}" ; do
      if [ -n "$envfile" -a ! -e "$envfile" ]; then
        fatal "Invalid ENVFILE ($envfile)"
      fi
    done
  }

  function assert_valid_shares() {
    for share in "${shares[@]}" ; do
      local lhs=$(echo "$share" | cut -f1 -d:)
      local rhs=$(echo "$share" | cut -f2 -d:)
      if [ ! -e "$lhs" ]; then
        fatal "Invalid --share ($share)"
      fi
      if [ "${rhs::1}" == "/" ]; then
        fatal "Invalid --share ($share): RHS must be relative"
      fi
      case "$rhs" in
        /*) fatal "Invalid --share ($share): RHS must be relative" ; ;;
        *..*) fatal "Invalid --share ($share): RHS must be relative" ; ;;
      esac
    done
  }

  function assert_ownership() {
    _assert_owner "$SUDO_UID" "$img"
    for share in "${shares[@]}"; do
      local lhs=$(echo "$share" | cut -f1 -d:)
      local rhs=$(echo "$share" | cut -f2 -d:)
      _assert_owner "$SUDO_UID" "$lhs"
    done
  }

  ## usage:_assert_owner UID FILES...
  function _assert_owner() {
    local uid="$1"
    local file_uid
    shift
    for file in "$@" ; do
      local tgt="$file"
      while [ ! -e "$file" ]; do
        file=$(dirname "$file")
      done
      file_uid=$( stat -c %u "$file" )
      if [ "$uid" -ne "$file_uid" ]; then
        fatal "File $file not owned by $uid"
      fi
    done
  }

  function realize_shares() {
    local orig=("${shares[@]}")
    shares=()
    for orig in "${orig[@]}" ; do
      local lhs=$(echo "$orig" | cut -f1 -d:)
      local rhs=$(echo "$orig" | cut -f2 -d:)
      lhs=$(realpath "$lhs")
      shares+=("$lhs:$rhs")
    done
  }

  function realize_envfiles() {
    local orig=("${envfiles[@]}")
    envfiles=()
    for orig in "${orig[@]}" ; do
      orig=$(realpath "$orig")
      envfiles+=("$orig")
    done
  }

  function realize_img() {
    img=$(realpath "$img")
    homer_id=$(echo "$img" |md5sum - | cut -f1 -d\  )
    homer_lock=$( echo "${HOMER_LOCK_TPL}" | sed "s;HOMER_ID;${homer_id};" )
    homer_base=$( echo "${HOMER_BASE_TPL}" | sed "s;HOMER_ID;${homer_id};" )
    homer_temp=$( echo "${HOMER_TEMP_TPL}" | sed "s;HOMER_ID;${homer_id};" )
    homer_home=$( echo "${HOMER_HOME_TPL}" | sed "s;HOMER_ID;${homer_id};" )
    homer_ns=$( echo "${HOMER_NS_TPL}" | sed "s;HOMER_ID;${homer_id};" )
  }

  #########################################################
  ## Initialization
  trap task_cleanup EXIT

  parsing=1
  while [[ $# -gt 0 && -n "$parsing" ]]; do
    case "$1" in
      --)           parsing=          ; shift 1 ; ;;
      #--env)        envfiles+=("$2")  ; shift 2 ; ;;
      #--share)
      #  case "$2" in
      #    *:*) shares+=("$2") ;;
      #    *) shares+=("$2:$2") ;;
      #  esac
      #  shift 2
      #  ;;
      -v)           verbose=$((1 + $verbose)) ; shift 1 ; ;;
      -i|--img)     img="$2"          ; shift 2 ; ;;
      --owner-pid)  owner_pid="$2"    ; shift 2 ; ;;
      -t|--temp)    use_temp="--temp" ; shift 1 ; ;;
      -h|--help|help) action="usage"  ; shift 1 ; ;;
      install|uninstall|run|status|create|mount|unmount|exec) action="$1" ; shift ; ;;
      -*)           fatal "Unrecognized option $1" ; ;;
      *)            parsing=          ; ;;
    esac
  done
  action=${action:-run}

  while [[ $# -gt 0 ]]; do
    cmd+=("$1")
    shift
  done

  #echo "action=[$action] img=[$img] use_temp=[$use_temp] shares=[${shares[@]}] envfiles=[${envfiles[@]}]"
  #echo "cmd: [${cmd[@]}]"
  #exit

  f="task_${action}"
  $f
  exit $?
}

